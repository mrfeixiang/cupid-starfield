<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸ’˜ æ˜Ÿç©ºç²’å­ Â· ä¸€ç®­ç©¿å¿ƒ | Cupid's Arrow Starfield</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            overflow: hidden;
            background: #000;
            font-family: 'Segoe UI', 'Microsoft YaHei', sans-serif;
        }
        
        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        #video-container {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 200px;
            height: 150px;
            border-radius: 12px;
            overflow: hidden;
            border: 2px solid rgba(255, 100, 150, 0.5);
            box-shadow: 0 0 20px rgba(255, 100, 150, 0.3);
            z-index: 100;
            background: #111;
        }

        #video {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
        }

        #ui-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 30px;
        }

        .header {
            text-align: center;
        }

        h1 {
            font-size: 2.5rem;
            font-weight: 200;
            color: #fff;
            text-shadow: 0 0 30px rgba(255, 100, 150, 0.8);
            letter-spacing: 8px;
            margin-bottom: 10px;
        }

        .subtitle {
            font-size: 1rem;
            color: rgba(255, 180, 200, 0.8);
            letter-spacing: 2px;
        }

        .gesture-status {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            transition: all 0.5s ease;
        }

        .gesture-icon {
            font-size: 4rem;
            margin-bottom: 15px;
            filter: drop-shadow(0 0 20px rgba(255, 100, 150, 0.8));
        }

        .gesture-text {
            font-size: 1.5rem;
            color: rgba(255, 255, 255, 0.9);
            text-shadow: 0 0 15px rgba(255, 100, 150, 0.6);
            letter-spacing: 3px;
        }

        .instructions {
            position: fixed;
            bottom: 30px;
            left: 30px;
            color: rgba(255, 255, 255, 0.6);
            font-size: 0.9rem;
            line-height: 1.8;
            pointer-events: auto;
        }

        .instructions span {
            color: #ff6b9d;
        }

        #loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            transition: opacity 0.8s ease;
        }

        .loading-heart {
            font-size: 5rem;
            animation: pulse 1.5s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 0.8; }
            50% { transform: scale(1.2); opacity: 1; }
        }

        .loading-text {
            margin-top: 20px;
            color: #ff6b9d;
            font-size: 1.2rem;
            letter-spacing: 3px;
        }

        .camera-permission {
            pointer-events: auto;
            margin-top: 30px;
            padding: 15px 40px;
            font-size: 1rem;
            background: linear-gradient(135deg, #ff6b9d, #c44569);
            border: none;
            border-radius: 30px;
            color: white;
            cursor: pointer;
            letter-spacing: 2px;
            transition: all 0.3s ease;
            box-shadow: 0 5px 20px rgba(255, 100, 150, 0.4);
        }

        .camera-permission:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 30px rgba(255, 100, 150, 0.6);
        }

        .no-camera-mode {
            margin-top: 15px;
            color: rgba(255, 255, 255, 0.5);
            font-size: 0.85rem;
            cursor: pointer;
            pointer-events: auto;
        }

        .no-camera-mode:hover {
            color: rgba(255, 255, 255, 0.8);
        }

        /* é¼ æ ‡æ¨¡å¼æŒ‰é’® */
        .mouse-controls {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 15px;
            z-index: 100;
            pointer-events: auto;
        }

        .mouse-btn {
            padding: 12px 25px;
            background: rgba(255, 100, 150, 0.15);
            border: 1px solid rgba(255, 100, 150, 0.4);
            border-radius: 25px;
            color: #ff9dbd;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }

        .mouse-btn:hover {
            background: rgba(255, 100, 150, 0.3);
            box-shadow: 0 0 20px rgba(255, 100, 150, 0.4);
        }

        .mouse-btn.active {
            background: linear-gradient(135deg, #ff6b9d, #c44569);
            color: white;
        }

        .hidden { display: none !important; }
    </style>
</head>
<body>

<div id="loading">
    <div class="loading-heart">ğŸ’˜</div>
    <div class="loading-text">æ­£åœ¨åˆå§‹åŒ–æ˜Ÿç©º...</div>
    <button class="camera-permission" id="start-btn">å¼€å¯æ‘„åƒå¤´ Â· æ‰‹åŠ¿äº¤äº’</button>
    <div class="no-camera-mode" id="mouse-mode-btn">æˆ–ä½¿ç”¨é¼ æ ‡/è§¦å±æ¨¡å¼</div>
</div>

<div id="canvas-container"></div>

<div id="video-container" class="hidden">
    <video id="video" playsinline></video>
</div>

<div id="ui-overlay">
    <div class="header">
        <h1>ğŸ’˜ CUPID'S STARFIELD</h1>
        <div class="subtitle">å¼ å¼€æ‰‹ Â· æ˜Ÿç©ºç’€ç’¨ | æ¡ç´§æ‹³ Â· ä¸€ç®­ç©¿å¿ƒ</div>
    </div>
</div>

<div class="gesture-status" id="gesture-status">
    <div class="gesture-icon" id="gesture-icon">âœ‹</div>
    <div class="gesture-text" id="gesture-text">å¼ å¼€æ‰‹æŒ</div>
</div>

<div class="instructions" id="instructions">
    <span>âœ‹ å¼ å¼€æ‰‹æŒ</span> â†’ æ˜Ÿç©ºæ•£å¼€<br>
    <span>âœŠ æ¡ç´§æ‹³å¤´</span> â†’ æ±‡èšæˆå¿ƒ
</div>

<div class="mouse-controls hidden" id="mouse-controls">
    <button class="mouse-btn active" id="btn-scatter">âœ‹ æ•£å¼€æ˜Ÿç©º</button>
    <button class="mouse-btn" id="btn-heart">ğŸ’˜ ä¸€ç®­ç©¿å¿ƒ</button>
</div>

<script>
// ============ é…ç½® ============
const CONFIG = {
    particleCount: 15000,
    starfieldRadius: 800,
    heartScale: 18,
    morphSpeed: 0.03,
    rotationSpeed: 0.001,
    colors: {
        star: [0xffffff, 0xffd1dc, 0xffb6c1, 0xff69b4, 0x87ceeb],
        heart: [0xff1493, 0xff69b4, 0xdc143c, 0xff6b9d, 0xffc0cb]
    }
};

// ============ å…¨å±€å˜é‡ ============
let scene, camera, renderer, particles;
let currentPositions, starPositions, heartPositions;
let particleColors, starColors, heartColors;
let morphProgress = 0;
let targetMorph = 0; // 0 = æ˜Ÿç©º, 1 = å¿ƒå½¢
let isHandOpen = true;
let useMouseMode = false;
let hands = null;
let videoElement = null;

// ============ åˆå§‹åŒ– ============
init();
animate();

function init() {
    // Three.js åœºæ™¯
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 3000);
    camera.position.z = 1000;

    renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setClearColor(0x000000, 1);
    document.getElementById('canvas-container').appendChild(renderer.domElement);

    // ç”Ÿæˆç›®æ ‡å½¢çŠ¶
    starPositions = generateStarfield(CONFIG.particleCount);
    heartPositions = generateCupidHeart(CONFIG.particleCount);
    
    // ç”Ÿæˆé¢œè‰²
    starColors = generateColors(CONFIG.particleCount, CONFIG.colors.star);
    heartColors = generateColors(CONFIG.particleCount, CONFIG.colors.heart);

    // åˆ›å»ºç²’å­ç³»ç»Ÿ
    createParticles();

    // äº‹ä»¶ç›‘å¬
    window.addEventListener('resize', onResize);
    
    // æŒ‰é’®äº‹ä»¶
    document.getElementById('start-btn').addEventListener('click', startCamera);
    document.getElementById('mouse-mode-btn').addEventListener('click', startMouseMode);
    document.getElementById('btn-scatter').addEventListener('click', () => setShape(false));
    document.getElementById('btn-heart').addEventListener('click', () => setShape(true));
}

// ============ ç”Ÿæˆæ˜Ÿç©ºåæ ‡ ============
function generateStarfield(count) {
    const positions = new Float32Array(count * 3);
    for (let i = 0; i < count; i++) {
        // çƒå½¢åˆ†å¸ƒ
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos(2 * Math.random() - 1);
        const r = Math.cbrt(Math.random()) * CONFIG.starfieldRadius;
        
        positions[i * 3] = r * Math.sin(phi) * Math.cos(theta);
        positions[i * 3 + 1] = r * Math.sin(phi) * Math.sin(theta);
        positions[i * 3 + 2] = r * Math.cos(phi);
    }
    return positions;
}

// ============ ç”Ÿæˆä¸˜æ¯”ç‰¹ä¸€ç®­ç©¿å¿ƒåæ ‡ ============
function generateCupidHeart(count) {
    const positions = new Float32Array(count * 3);
    const scale = CONFIG.heartScale;
    
    // åˆ†é…ç²’å­ï¼š70% å¿ƒå½¢, 20% ç®­èº«, 10% ç®­å¤´+ç®­ç¾½
    const heartCount = Math.floor(count * 0.7);
    const arrowCount = Math.floor(count * 0.2);
    const detailCount = count - heartCount - arrowCount;
    
    let idx = 0;
    
    // 1. å¿ƒå½¢ (å‚æ•°æ–¹ç¨‹)
    for (let i = 0; i < heartCount; i++) {
        const t = (i / heartCount) * Math.PI * 2;
        // å¿ƒå½¢å‚æ•°æ–¹ç¨‹
        let x = 16 * Math.pow(Math.sin(t), 3);
        let y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
        
        // æ·»åŠ åšåº¦å’Œéšæœºæ€§ï¼Œå½¢æˆç«‹ä½“æ„Ÿ
        const thickness = (Math.random() - 0.5) * 3;
        const depth = (Math.random() - 0.5) * 4;
        
        // å¡«å……å¿ƒå½¢å†…éƒ¨
        const fill = Math.random();
        if (fill < 0.4) {
            x *= Math.random() * 0.8 + 0.2;
            y *= Math.random() * 0.8 + 0.2;
        }
        
        positions[idx * 3] = x * scale + thickness * scale * 0.3;
        positions[idx * 3 + 1] = y * scale;
        positions[idx * 3 + 2] = depth * scale * 0.5;
        idx++;
    }
    
    // 2. ç®­èº« (æ–œç©¿å¿ƒè„)
    const arrowStart = { x: -22, y: -15 };
    const arrowEnd = { x: 22, y: 15 };
    
    for (let i = 0; i < arrowCount; i++) {
        const t = i / arrowCount;
        const x = arrowStart.x + (arrowEnd.x - arrowStart.x) * t;
        const y = arrowStart.y + (arrowEnd.y - arrowStart.y) * t;
        
        // ç®­èº«åšåº¦
        const offsetX = (Math.random() - 0.5) * 1.5;
        const offsetY = (Math.random() - 0.5) * 1.5;
        const offsetZ = (Math.random() - 0.5) * 2;
        
        positions[idx * 3] = x * scale + offsetX * scale * 0.2;
        positions[idx * 3 + 1] = y * scale + offsetY * scale * 0.2;
        positions[idx * 3 + 2] = offsetZ * scale * 0.3;
        idx++;
    }
    
    // 3. ç®­å¤´ (ä¸‰è§’å½¢)
    const arrowheadCount = Math.floor(detailCount * 0.5);
    for (let i = 0; i < arrowheadCount; i++) {
        // ç®­å¤´å°–ç«¯åœ¨å³ä¸Šæ–¹
        const tipX = 25;
        const tipY = 18;
        
        // éšæœºåˆ†å¸ƒåœ¨ä¸‰è§’å½¢ç®­å¤´åŒºåŸŸ
        const r1 = Math.random();
        const r2 = Math.random();
        const sqrt_r1 = Math.sqrt(r1);
        
        // ä¸‰è§’å½¢é¡¶ç‚¹
        const v0 = { x: tipX, y: tipY };
        const v1 = { x: tipX - 5, y: tipY + 3 };
        const v2 = { x: tipX - 5, y: tipY - 3 };
        
        const x = (1 - sqrt_r1) * v0.x + sqrt_r1 * (1 - r2) * v1.x + sqrt_r1 * r2 * v2.x;
        const y = (1 - sqrt_r1) * v0.y + sqrt_r1 * (1 - r2) * v1.y + sqrt_r1 * r2 * v2.y;
        const z = (Math.random() - 0.5) * 2;
        
        positions[idx * 3] = x * scale;
        positions[idx * 3 + 1] = y * scale;
        positions[idx * 3 + 2] = z * scale * 0.3;
        idx++;
    }
    
    // 4. ç®­ç¾½ (å°¾éƒ¨ç¾½æ¯›)
    const featherCount = detailCount - arrowheadCount;
    for (let i = 0; i < featherCount; i++) {
        // ç¾½æ¯›åœ¨å·¦ä¸‹æ–¹
        const baseX = -24;
        const baseY = -17;
        
        // ä¸¤ç‰‡ç¾½æ¯›
        const side = i % 2 === 0 ? 1 : -1;
        const t = Math.random();
        
        const x = baseX - t * 4;
        const y = baseY + side * (1 + t * 3) + (Math.random() - 0.5);
        const z = (Math.random() - 0.5) * 3;
        
        positions[idx * 3] = x * scale;
        positions[idx * 3 + 1] = y * scale;
        positions[idx * 3 + 2] = z * scale * 0.3;
        idx++;
    }
    
    return positions;
}

// ============ ç”Ÿæˆé¢œè‰² ============
function generateColors(count, palette) {
    const colors = new Float32Array(count * 3);
    const color = new THREE.Color();
    
    for (let i = 0; i < count; i++) {
        const hex = palette[Math.floor(Math.random() * palette.length)];
        color.setHex(hex);
        colors[i * 3] = color.r;
        colors[i * 3 + 1] = color.g;
        colors[i * 3 + 2] = color.b;
    }
    return colors;
}

// ============ åˆ›å»ºç²’å­ç³»ç»Ÿ ============
function createParticles() {
    const geometry = new THREE.BufferGeometry();
    
    // åˆå§‹ä½ç½® = æ˜Ÿç©º
    currentPositions = new Float32Array(starPositions);
    particleColors = new Float32Array(starColors);
    
    geometry.setAttribute('position', new THREE.BufferAttribute(currentPositions, 3));
    geometry.setAttribute('color', new THREE.BufferAttribute(particleColors, 3));
    
    // å‘å…‰çº¹ç†
    const sprite = createGlowSprite();
    
    const material = new THREE.PointsMaterial({
        size: 4,
        map: sprite,
        vertexColors: true,
        blending: THREE.AdditiveBlending,
        depthWrite: false,
        transparent: true,
        opacity: 0.9
    });
    
    particles = new THREE.Points(geometry, material);
    scene.add(particles);
}

function createGlowSprite() {
    const canvas = document.createElement('canvas');
    canvas.width = 64;
    canvas.height = 64;
    const ctx = canvas.getContext('2d');
    
    const gradient = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
    gradient.addColorStop(0, 'rgba(255,255,255,1)');
    gradient.addColorStop(0.1, 'rgba(255,255,255,0.9)');
    gradient.addColorStop(0.4, 'rgba(255,200,220,0.4)');
    gradient.addColorStop(1, 'rgba(0,0,0,0)');
    
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, 64, 64);
    
    const texture = new THREE.Texture(canvas);
    texture.needsUpdate = true;
    return texture;
}

// ============ åŠ¨ç”»å¾ªç¯ ============
function animate() {
    requestAnimationFrame(animate);
    
    // ç¼“æ…¢æ—‹è½¬
    if (particles) {
        particles.rotation.y += CONFIG.rotationSpeed;
        
        // å½¢æ€å˜æ¢
        updateMorph();
    }
    
    renderer.render(scene, camera);
}

function updateMorph() {
    // å¹³æ»‘è¿‡æ¸¡åˆ°ç›®æ ‡çŠ¶æ€
    const delta = targetMorph - morphProgress;
    morphProgress += delta * CONFIG.morphSpeed;
    
    const positions = particles.geometry.attributes.position.array;
    const colors = particles.geometry.attributes.color.array;
    
    for (let i = 0; i < CONFIG.particleCount; i++) {
        const i3 = i * 3;
        
        // ä½ç½®æ’å€¼
        positions[i3] = starPositions[i3] + (heartPositions[i3] - starPositions[i3]) * morphProgress;
        positions[i3 + 1] = starPositions[i3 + 1] + (heartPositions[i3 + 1] - starPositions[i3 + 1]) * morphProgress;
        positions[i3 + 2] = starPositions[i3 + 2] + (heartPositions[i3 + 2] - starPositions[i3 + 2]) * morphProgress;
        
        // é¢œè‰²æ’å€¼
        colors[i3] = starColors[i3] + (heartColors[i3] - starColors[i3]) * morphProgress;
        colors[i3 + 1] = starColors[i3 + 1] + (heartColors[i3 + 1] - starColors[i3 + 1]) * morphProgress;
        colors[i3 + 2] = starColors[i3 + 2] + (heartColors[i3 + 2] - starColors[i3 + 2]) * morphProgress;
    }
    
    particles.geometry.attributes.position.needsUpdate = true;
    particles.geometry.attributes.color.needsUpdate = true;
}

// ============ æ‰‹åŠ¿æ£€æµ‹ ============
async function startCamera() {
    try {
        videoElement = document.getElementById('video');
        
        // åˆå§‹åŒ– MediaPipe Hands
        hands = new Hands({
            locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
        });
        
        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.7,
            minTrackingConfidence: 0.5
        });
        
        hands.onResults(onHandResults);
        
        // å¯åŠ¨æ‘„åƒå¤´
        const camera = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({ image: videoElement });
            },
            width: 640,
            height: 480
        });
        
        await camera.start();
        
        // æ˜¾ç¤ºè§†é¢‘
        document.getElementById('video-container').classList.remove('hidden');
        document.getElementById('loading').style.opacity = '0';
        setTimeout(() => {
            document.getElementById('loading').classList.add('hidden');
        }, 800);
        
    } catch (error) {
        console.error('æ‘„åƒå¤´å¯åŠ¨å¤±è´¥:', error);
        alert('æ— æ³•è®¿é—®æ‘„åƒå¤´ï¼Œå°†åˆ‡æ¢åˆ°é¼ æ ‡æ¨¡å¼');
        startMouseMode();
    }
}

function onHandResults(results) {
    if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
        const landmarks = results.multiHandLandmarks[0];
        
        // æ£€æµ‹æ‰‹åŠ¿ï¼šå¼ å¼€ vs æ¡æ‹³
        const isOpen = detectOpenHand(landmarks);
        
        if (isOpen !== isHandOpen) {
            isHandOpen = isOpen;
            setShape(!isOpen);
        }
    }
}

function detectOpenHand(landmarks) {
    // ç®€å•çš„å¼ å¼€/æ¡æ‹³æ£€æµ‹
    // æ¯”è¾ƒæŒ‡å°–ä¸æŒå¿ƒçš„è·ç¦»
    
    const palmCenter = landmarks[0]; // æ‰‹è…•
    const fingerTips = [
        landmarks[4],  // æ‹‡æŒ‡
        landmarks[8],  // é£ŸæŒ‡
        landmarks[12], // ä¸­æŒ‡
        landmarks[16], // æ— åæŒ‡
        landmarks[20]  // å°æŒ‡
    ];
    
    // è®¡ç®—æ¯ä¸ªæŒ‡å°–åˆ°æ‰‹è…•çš„è·ç¦»
    let totalDist = 0;
    for (const tip of fingerTips) {
        const dx = tip.x - palmCenter.x;
        const dy = tip.y - palmCenter.y;
        totalDist += Math.sqrt(dx * dx + dy * dy);
    }
    
    const avgDist = totalDist / 5;
    
    // é˜ˆå€¼åˆ¤æ–­ï¼šè·ç¦»å¤§è¯´æ˜æ‰‹å¼ å¼€
    return avgDist > 0.25;
}

// ============ é¼ æ ‡æ¨¡å¼ ============
function startMouseMode() {
    useMouseMode = true;
    document.getElementById('loading').style.opacity = '0';
    setTimeout(() => {
        document.getElementById('loading').classList.add('hidden');
    }, 800);
    
    document.getElementById('mouse-controls').classList.remove('hidden');
    document.getElementById('instructions').classList.add('hidden');
}

function setShape(isHeart) {
    targetMorph = isHeart ? 1 : 0;
    
    // æ›´æ–°UI
    const icon = document.getElementById('gesture-icon');
    const text = document.getElementById('gesture-text');
    
    if (isHeart) {
        icon.textContent = 'ğŸ’˜';
        text.textContent = 'ä¸€ç®­ç©¿å¿ƒ';
        document.getElementById('btn-scatter')?.classList.remove('active');
        document.getElementById('btn-heart')?.classList.add('active');
    } else {
        icon.textContent = 'âœ‹';
        text.textContent = 'æ˜Ÿç©ºç’€ç’¨';
        document.getElementById('btn-scatter')?.classList.add('active');
        document.getElementById('btn-heart')?.classList.remove('active');
    }
}

// ============ çª—å£è°ƒæ•´ ============
function onResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
}
</script>

</body>
</html>
